#!/usr/bin/env python3
"""
Voice Controller robuste avec gestion d'erreurs am√©lior√©e
"""
import asyncio
import json
import os
import sys
import sounddevice as sd
import numpy as np
import websockets
from dotenv import load_dotenv
from pathlib import Path
import threading
import signal
import queue

load_dotenv()

class VoiceControllerRobust:
    def __init__(self):
        self.api_key = os.getenv('OPENAI_API_KEY')
        self.model = os.getenv('OPENAI_REALTIME_MODEL', 'gpt-4o-realtime-preview')
        self.ws = None
        self.is_recording = False
        self.desktop_path = Path.home() / "Desktop"
        self.recording_stopped = threading.Event()
        # Queue thread-safe pour communiquer entre le callback audio et asyncio
        self.audio_queue = queue.Queue(maxsize=100)
        # √âtat de connexion
        self.connection_active = True
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 5
        # Variables pour le feedback visuel
        self.current_volume = 0.0
        self.show_volume_bar = False
        
    # ========== FONCTIONS D'OUTILS ==========
    def create_folder(self, folder_path):
        """Cr√©er un dossier"""
        try:
            full_path = self.desktop_path / folder_path
            full_path.mkdir(parents=True, exist_ok=True)
            return f"‚úÖ Dossier cr√©√©: {full_path.name}"
        except Exception as e:
            return f"‚ùå Erreur cr√©ation dossier: {e}"
    
    def create_file(self, file_path):
        """Cr√©er un fichier vide"""
        try:
            full_path = self.desktop_path / file_path
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.touch()
            return f"‚úÖ Fichier cr√©√©: {full_path.name}"
        except Exception as e:
            return f"‚ùå Erreur cr√©ation fichier: {e}"
    
    def list_contents(self, folder_path=""):
        """Lister le contenu d'un dossier"""
        try:
            if folder_path:
                target_path = self.desktop_path / folder_path
            else:
                target_path = self.desktop_path
            
            if not target_path.exists():
                return f"‚ùå Dossier introuvable: {target_path}"
            
            items = list(target_path.iterdir())
            if not items:
                return f"üìÅ Dossier vide: {target_path.name}"
            
            result = f"üìÅ Contenu de {target_path.name}:\n"
            for item in sorted(items):
                icon = "üìÅ" if item.is_dir() else "üìÑ"
                result += f"  {icon} {item.name}\n"
            return result
        except Exception as e:
            return f"‚ùå Erreur lecture dossier: {e}"
    
    async def execute_function_call(self, function_name, arguments):
        """Ex√©cuter un appel de fonction"""
        print(f"üõ†Ô∏è Ex√©cution: {function_name}({arguments})")
        
        try:
            if function_name == "create_folder":
                return self.create_folder(arguments.get("folder_path", ""))
            elif function_name == "create_file":
                return self.create_file(arguments.get("file_path", ""))
            elif function_name == "list_contents":
                return self.list_contents(arguments.get("folder_path", ""))
            else:
                return f"‚ùå Fonction inconnue: {function_name}"
        except Exception as e:
            return f"‚ùå Erreur ex√©cution: {e}"
    
    # ========== CONNEXION ET CONFIGURATION ==========
    async def connect_to_realtime(self, max_retries=3):
        """Se connecter √† l'API OpenAI Realtime avec retry logic"""
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'OpenAI-Beta': 'realtime=v1'
        }
        
        uri = f"wss://api.openai.com/v1/realtime?model={self.model}"
        
        for attempt in range(max_retries):
            try:
                print(f"üîó Tentative de connexion {attempt + 1}/{max_retries}...")
                
                # Configuration WebSocket optimis√©e pour la stabilit√©
                self.ws = await websockets.connect(
                    uri, 
                    additional_headers=headers,
                    ping_interval=30,  # Ping toutes les 30 secondes
                    ping_timeout=10,   # Timeout de 10 secondes pour les pings
                    close_timeout=10,  # Timeout de fermeture
                    max_size=None,     # Pas de limite de taille des messages
                    compression=None   # D√©sactiver la compression pour r√©duire la latence
                )
                print("‚úÖ Connect√© √† OpenAI Realtime API")
                return True
                
            except Exception as e:
                print(f"‚ùå Erreur de connexion (tentative {attempt + 1}): {e}")
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt  # Backoff exponentiel
                    print(f"‚è≥ Nouvelle tentative dans {wait_time} secondes...")
                    await asyncio.sleep(wait_time)
                else:
                    print("‚ùå √âchec de toutes les tentatives de connexion")
                    
        return False
    
    async def send_session_config(self):
        """Configuration de session avec outils"""
        config = {
            "type": "session.update",
            "session": {
                "modalities": ["text", "audio"],
                "instructions": """Tu es un assistant vocal fran√ßais qui peut g√©rer des fichiers sur le bureau Mac. 
                
Quand l'utilisateur demande de cr√©er des dossiers/fichiers ou lister le contenu, utilise OBLIGATOIREMENT les outils disponibles.

Exemples:
- "cr√©e 3 dossiers" ‚Üí utilise create_folder 3 fois avec des noms comme "dossier-1", "dossier-2", "dossier-3"
- "liste le bureau" ‚Üí utilise list_contents
- "cr√©e un fichier test.txt" ‚Üí utilise create_file

IMPORTANT: Utilise toujours les outils, ne r√©ponds jamais sans action.""",
                "voice": "alloy",
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {"model": "whisper-1"},
                "tools": [
                    {
                        "type": "function",
                        "name": "create_folder",
                        "description": "Cr√©er un dossier sur le bureau",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "folder_path": {
                                    "type": "string",
                                    "description": "Nom du dossier √† cr√©er"
                                }
                            },
                            "required": ["folder_path"]
                        }
                    },
                    {
                        "type": "function",
                        "name": "create_file",
                        "description": "Cr√©er un fichier vide sur le bureau",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "file_path": {
                                    "type": "string",
                                    "description": "Nom du fichier √† cr√©er"
                                }
                            },
                            "required": ["file_path"]
                        }
                    },
                    {
                        "type": "function",
                        "name": "list_contents",
                        "description": "Lister le contenu du bureau",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "folder_path": {
                                    "type": "string",
                                    "description": "Chemin du dossier (vide pour le bureau)"
                                }
                            }
                        }
                    }
                ]
            }
        }
        
        try:
            await self.ws.send(json.dumps(config))
            print("üì§ Configuration avec outils envoy√©e")
        except Exception as e:
            print(f"‚ùå Erreur envoi config: {e}")
    
    async def listen_to_responses(self):
        """√âcouter les r√©ponses de l'API avec gestion de reconnexion"""
        while self.connection_active:
            try:
                async for message in self.ws:
                    try:
                        data = json.loads(message)
                        message_type = data.get("type")
                        
                        print(f"üîç Message re√ßu: {message_type}")
                        
                        if message_type == "session.created":
                            print("‚úÖ Session cr√©√©e")
                            self.reconnect_attempts = 0  # Reset sur succ√®s
                        elif message_type == "input_audio_buffer.speech_started":
                            print("üé§ Parole d√©tect√©e")
                        elif message_type == "input_audio_buffer.speech_stopped":
                            print("üîá Fin de parole")
                        elif message_type == "conversation.item.input_audio_transcription.completed":
                            transcript = data.get("transcript", "")
                            print(f"üìù Vous avez dit: '{transcript}'")
                        elif message_type == "response.function_call_arguments.delta":
                            # Arguments de fonction en cours
                            print("üìû Pr√©paration appel de fonction...")
                        elif message_type == "response.function_call_arguments.done":
                            # Appel de fonction termin√©
                            function_name = data.get("name")
                            arguments_str = data.get("arguments", "{}")
                            call_id = data.get("call_id")
                            
                            try:
                                arguments = json.loads(arguments_str) if arguments_str else {}
                            except json.JSONDecodeError:
                                arguments = {}
                            
                            # Ex√©cuter la fonction
                            result = await self.execute_function_call(function_name, arguments)
                            print(f"üì§ R√©sultat: {result}")
                            
                            # Envoyer le r√©sultat √† l'API
                            function_result = {
                                "type": "conversation.item.create",
                                "item": {
                                    "type": "function_call_output",
                                    "call_id": call_id,
                                    "output": str(result)
                                }
                            }
                            await self.safe_send(json.dumps(function_result))
                            
                            # Demander une nouvelle r√©ponse
                            await self.safe_send(json.dumps({"type": "response.create"}))
                            
                        elif message_type == "response.text.delta":
                            text = data.get("delta", "")
                            print(text, end="", flush=True)
                        elif message_type == "response.done":
                            print("\n‚úÖ R√©ponse termin√©e")
                        elif message_type == "error":
                            error_details = data.get("error", {})
                            print(f"‚ùå Erreur API: {error_details}")
                        
                    except json.JSONDecodeError:
                        print(f"‚ùå Erreur parsing JSON: {message}")
                    except Exception as e:
                        print(f"‚ùå Erreur traitement message: {e}")
                        
            except websockets.exceptions.ConnectionClosed as e:
                print(f"üîå Connexion ferm√©e: {e}")
                if self.connection_active and not await self.handle_reconnection():
                    break
            except Exception as e:
                print(f"‚ùå Erreur √©coute: {e}")
                if self.connection_active and not await self.handle_reconnection():
                    break
    
    async def handle_reconnection(self):
        """G√®re la reconnexion automatique"""
        if self.reconnect_attempts >= self.max_reconnect_attempts:
            print(f"‚ùå Nombre maximum de tentatives de reconnexion atteint ({self.max_reconnect_attempts})")
            self.connection_active = False
            return False
        
        self.reconnect_attempts += 1
        wait_time = min(30, 2 ** self.reconnect_attempts)  # Backoff avec maximum de 30s
        
        print(f"üîÑ Tentative de reconnexion {self.reconnect_attempts}/{self.max_reconnect_attempts} dans {wait_time}s...")
        await asyncio.sleep(wait_time)
        
        if await self.connect_to_realtime(max_retries=1):
            print("‚úÖ Reconnexion r√©ussie!")
            await self.send_session_config()
            return True
        else:
            print("‚ùå √âchec de la reconnexion")
            return False
    
    def audio_callback(self, indata, frames, time, status):
        """Callback pour l'audio en temps r√©el - VERSION CORRIG√âE"""
        if status:
            print(f"‚ö†Ô∏è Statut audio: {status}")
        
        if self.is_recording and self.ws:
            try:
                # Convertir en PCM16
                audio_data = (indata[:, 0] * 32767).astype(np.int16)
                
                # Calculer le volume pour le feedback visuel
                volume_norm = np.linalg.norm(indata[:, 0]) * 10
                self.current_volume = volume_norm
                
                # V√©rifier que les donn√©es ne sont pas silencieuses
                max_amplitude = np.max(np.abs(audio_data))
                if max_amplitude > 10:  # Seuil tr√®s bas (corrig√© de 100 √† 10)
                    audio_b64 = self.numpy_to_base64(audio_data)
                    
                    # Envoyer √† l'API de mani√®re s√©curis√©e
                    message = {
                        "type": "input_audio_buffer.append",
                        "audio": audio_b64
                    }
                    
                    # ‚úÖ SOLUTION: Utiliser une queue thread-safe au lieu d'asyncio
                    try:
                        self.audio_queue.put_nowait(json.dumps(message))
                    except queue.Full:
                        # Si la queue est pleine, on ignore ce chunk audio
                        pass
                    
            except Exception as e:
                print(f"‚ùå Erreur callback audio: {e}")
    
    async def process_audio_queue(self):
        """Traiter la queue d'audio de mani√®re asynchrone"""
        while True:
            try:
                # Attendre un message de la queue avec timeout
                message = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.audio_queue.get(timeout=0.1)
                )
                await self.safe_send(message)
            except queue.Empty:
                # Pas de message, continuer
                await asyncio.sleep(0.01)
            except Exception as e:
                print(f"‚ùå Erreur traitement queue audio: {e}")
    
    async def safe_send(self, message):
        """Envoi s√©curis√© de message avec gestion d'erreur am√©lior√©e"""
        try:
            if self.ws:
                await self.ws.send(message)
        except websockets.exceptions.ConnectionClosed:
            print("üîå Connexion ferm√©e lors de l'envoi")
            # Ne pas imprimer l'erreur de keepalive ping timeout r√©p√©titivement
            return
        except Exception as e:
            # Filtrer les erreurs de keepalive ping timeout r√©p√©titives
            if "keepalive ping timeout" not in str(e):
                print(f"‚ùå Erreur envoi: {e}")
    
    def numpy_to_base64(self, audio_data):
        """Convertir numpy array en base64"""
        import base64
        return base64.b64encode(audio_data.tobytes()).decode('utf-8')
    
    def wait_for_enter(self):
        """Attendre l'entr√©e utilisateur dans un thread s√©par√©"""
        try:
            input("Appuyez sur Entr√©e pour arr√™ter...")
            self.recording_stopped.set()
        except:
            self.recording_stopped.set()
    
    async def start_recording(self):
        """D√©marrer l'enregistrement"""
        self.is_recording = True
        self.recording_stopped.clear()
        print("üé§ Enregistrement d√©marr√© - Parlez maintenant!")
        
        # D√©marrer l'attente d'entr√©e dans un thread
        input_thread = threading.Thread(target=self.wait_for_enter)
        input_thread.daemon = True
        input_thread.start()
        
        try:
            with sd.InputStream(
                callback=self.audio_callback,
                channels=1,
                samplerate=24000,
                dtype=np.float32
            ):
                # Attendre que l'utilisateur appuie sur Entr√©e
                while not self.recording_stopped.is_set():
                    await asyncio.sleep(0.1)
                    
        except Exception as e:
            print(f"‚ùå Erreur enregistrement: {e}")
        
        self.is_recording = False
        print("üîá Enregistrement arr√™t√©")
        
        # Finaliser l'audio
        try:
            await self.ws.send(json.dumps({"type": "input_audio_buffer.commit"}))
            await self.ws.send(json.dumps({"type": "response.create"}))
            print("üì§ Audio envoy√© pour traitement")
        except Exception as e:
            print(f"‚ùå Erreur finalisation: {e}")
    
    def show_test_menu(self):
        """Affiche le menu des commandes de test"""
        print("\n" + "="*50)
        print("üß™ MODE TEST - COMMANDES CLAVIER")
        print("="*50)
        print("1Ô∏è‚É£  - Cr√©er un dossier 'test-dossier'")
        print("2Ô∏è‚É£  - Cr√©er 3 dossiers (dossier-1, dossier-2, dossier-3)")
        print("3Ô∏è‚É£  - Cr√©er un fichier 'test.txt'")
        print("4Ô∏è‚É£  - Cr√©er plusieurs fichiers (.txt, .py, .md)")
        print("5Ô∏è‚É£  - Lister le contenu du bureau")
        print("6Ô∏è‚É£  - Cr√©er une structure projet compl√®te")
        print("üé§ - Passer en mode vocal (Entr√©e)")
        print("‚ùå - Quitter (q)")
        print("="*50)
    
    async def execute_test_command(self, command):
        """Ex√©cute une commande de test selon le num√©ro choisi"""
        print(f"\nüß™ Ex√©cution de la commande de test: {command}")
        
        if command == "1":
            # Test: cr√©er un dossier
            result = await self.execute_function_call("create_folder", {"folder_path": "test-dossier"})
            print(f"üì§ R√©sultat: {result}")
            
        elif command == "2":
            # Test: cr√©er 3 dossiers
            for i in range(1, 4):
                result = await self.execute_function_call("create_folder", {"folder_path": f"dossier-{i}"})
                print(f"üì§ R√©sultat: {result}")
                await asyncio.sleep(0.5)  # Petite pause entre les cr√©ations
                
        elif command == "3":
            # Test: cr√©er un fichier
            result = await self.execute_function_call("create_file", {"file_path": "test.txt"})
            print(f"üì§ R√©sultat: {result}")
            
        elif command == "4":
            # Test: cr√©er plusieurs fichiers
            files = ["readme.txt", "script.py", "documentation.md", "config.json"]
            for file in files:
                result = await self.execute_function_call("create_file", {"file_path": file})
                print(f"üì§ R√©sultat: {result}")
                await asyncio.sleep(0.3)
                
        elif command == "5":
            # Test: lister le contenu
            result = await self.execute_function_call("list_contents", {"folder_path": ""})
            print(f"üì§ R√©sultat:\n{result}")
            
        elif command == "6":
            # Test: cr√©er une structure projet compl√®te
            print("üèóÔ∏è Cr√©ation d'une structure de projet compl√®te...")
            
            # Cr√©er les dossiers
            folders = ["mon-projet", "mon-projet/src", "mon-projet/docs", "mon-projet/tests"]
            for folder in folders:
                result = await self.execute_function_call("create_folder", {"folder_path": folder})
                print(f"üìÅ {result}")
                await asyncio.sleep(0.2)
            
            # Cr√©er les fichiers
            files = [
                "mon-projet/README.md",
                "mon-projet/requirements.txt",
                "mon-projet/src/main.py",
                "mon-projet/src/utils.py",
                "mon-projet/docs/guide.md",
                "mon-projet/tests/test_main.py"
            ]
            for file in files:
                result = await self.execute_function_call("create_file", {"file_path": file})
                print(f"üìÑ {result}")
                await asyncio.sleep(0.2)
                
            print("‚úÖ Structure de projet cr√©√©e avec succ√®s!")
        
        else:
            print("‚ùå Commande inconnue")
    
    async def run(self):
        """Fonction principale avec mode test"""
        print("üé§ VOICE CONTROLLER ROBUSTE")
        print("="*40)
        print(f"üìÅ Bureau: {self.desktop_path}")
        
        if not await self.connect_to_realtime():
            return
        
        await self.send_session_config()
        
        # D√©marrer l'√©coute des r√©ponses
        response_task = asyncio.create_task(self.listen_to_responses())
        
        # ‚úÖ SOLUTION: D√©marrer le traitement de la queue audio
        audio_queue_task = asyncio.create_task(self.process_audio_queue())
        
        try:
            while True:
                try:
                    self.show_test_menu()
                    user_input = input("\nüëâ Votre choix: ").strip()
                    
                    if user_input.lower() == 'q':
                        break
                    elif user_input == "":
                        # Mode vocal
                        print("\nüé§ Mode vocal activ√© - Parlez maintenant!")
                        await self.start_recording()
                        # Attendre un peu avant la prochaine commande
                        await asyncio.sleep(2)
                    elif user_input in ["1", "2", "3", "4", "5", "6"]:
                        # Mode test
                        await self.execute_test_command(user_input)
                        input("\nAppuyez sur Entr√©e pour continuer...")
                    else:
                        print("‚ùå Choix invalide. Utilisez 1-6, Entr√©e (vocal) ou 'q' (quitter)")
                        
                except EOFError:
                    print("\nüëã Au revoir!")
                    break
                
        except KeyboardInterrupt:
            print("\nüëã Au revoir!")
        finally:
            self.connection_active = False  # Arr√™ter les tentatives de reconnexion
            response_task.cancel()
            audio_queue_task.cancel()
            if self.ws:
                try:
                    await self.ws.close()
                except:
                    pass

if __name__ == "__main__":
    # G√©rer proprement Ctrl+C
    def signal_handler(sig, frame):
        print('\nüëã Arr√™t du programme...')
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        asyncio.run(VoiceControllerRobust().run())
    except KeyboardInterrupt:
        print("\nüëã Programme arr√™t√©")