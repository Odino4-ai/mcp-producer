#!/usr/bin/env python3
"""
Contr√¥leur vocal simplifi√© pour la gestion de fichiers
Version sans audio pour tester la connexion et les fonctions MCP
"""

import asyncio
import json
import os
import sys
from typing import Dict, Any

import websockets
from dotenv import load_dotenv


class VoiceControllerSimple:
    """Contr√¥leur vocal simplifi√© (sans audio)"""
    
    def __init__(self):
        """Initialise le contr√¥leur"""
        # Charge les variables d'environnement
        load_dotenv()
        
        self.api_key = os.getenv('OPENAI_API_KEY')
        self.model = os.getenv('OPENAI_REALTIME_MODEL', 'gpt-4o-realtime-preview')
        
        if not self.api_key:
            raise ValueError("OPENAI_API_KEY non trouv√©e dans les variables d'environnement")
        
        # √âtat de l'application
        self.websocket = None
        self.is_connected = False
        
        print(f"üé§ Voice Controller Simple initialis√©")
        print(f"   - Mod√®le: {self.model}")
        print(f"   - API Key: {self.api_key[:20]}...")
    
    def create_session_config(self) -> Dict[str, Any]:
        """Cr√©e la configuration de session avec les fonctions MCP simul√©es"""
        return {
            "type": "session.update",
            "session": {
                "modalities": ["text"],  # Pas d'audio pour cette version
                "instructions": """Tu es un assistant pour la gestion de fichiers. Tu peux cr√©er des dossiers, des fichiers, et lister le contenu du syst√®me de fichiers. 

Utilise les fonctions disponibles pour r√©pondre aux demandes de l'utilisateur. R√©ponds de mani√®re concise et utile en fran√ßais.

Fonctions disponibles:
- create_folder: Cr√©er un dossier
- create_file: Cr√©er un fichier vide
- list_contents: Lister le contenu d'un dossier

Sois amical et professionnel dans tes r√©ponses.""",
                "voice": "alloy",
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {
                    "model": "whisper-1"
                },
                "turn_detection": {
                    "type": "server_vad",
                    "threshold": 0.5,
                    "prefix_padding_ms": 300,
                    "silence_duration_ms": 200
                },
                "tools": [
                    {
                        "type": "function",
                        "function": {
                            "name": "create_folder",
                            "description": "Cr√©e un nouveau dossier sur le Desktop",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "folder_path": {
                                        "type": "string",
                                        "description": "Chemin du dossier √† cr√©er (ex: 'mon-projet' ou 'projet/sous-dossier')"
                                    }
                                },
                                "required": ["folder_path"]
                            }
                        }
                    },
                    {
                        "type": "function",
                        "function": {
                            "name": "create_file",
                            "description": "Cr√©e un fichier vide dans un dossier",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "file_path": {
                                        "type": "string",
                                        "description": "Chemin du fichier √† cr√©er (ex: 'mon-fichier.txt' ou 'projet/fichier.txt')"
                                    }
                                },
                                "required": ["file_path"]
                            }
                        }
                    },
                    {
                        "type": "function",
                        "function": {
                            "name": "list_contents",
                            "description": "Liste le contenu d'un dossier",
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "folder_path": {
                                        "type": "string",
                                        "description": "Chemin du dossier √† lister (vide pour lister le Desktop)"
                                    }
                                },
                                "required": []
                            }
                        }
                    }
                ],
                "tool_choice": "auto",
                "temperature": 0.8,
                "max_response_output_tokens": 4096
            }
        }
    
    async def connect_to_api(self):
        """Se connecte √† l'API OpenAI Realtime"""
        url = f"wss://api.openai.com/v1/realtime?model={self.model}"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "OpenAI-Beta": "realtime=v1"
        }
        
        print(f"üîó Connexion √† l'API OpenAI Realtime...")
        
        try:
            self.websocket = await websockets.connect(url, additional_headers=headers)
            self.is_connected = True
            print("‚úÖ Connexion WebSocket √©tablie!")
            
            # Envoie la configuration de session
            session_config = self.create_session_config()
            await self.websocket.send(json.dumps(session_config))
            print("üì§ Configuration de session envoy√©e")
            
            # D√©marre la t√¢che de r√©ception des messages
            asyncio.create_task(self.handle_messages())
            
        except Exception as e:
            print(f"‚ùå Erreur de connexion: {e}")
            self.is_connected = False
            raise
    
    async def handle_messages(self):
        """G√®re les messages re√ßus de l'API"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                await self.process_message(data)
        except websockets.exceptions.ConnectionClosed:
            print("üîå Connexion ferm√©e par le serveur")
            self.is_connected = False
        except Exception as e:
            print(f"‚ùå Erreur de r√©ception: {e}")
            self.is_connected = False
    
    async def process_message(self, data: Dict[str, Any]):
        """Traite un message re√ßu de l'API"""
        message_type = data.get("type")
        
        if message_type == "session.created":
            print("‚úÖ Session cr√©√©e avec succ√®s")
            
        elif message_type == "session.updated":
            print("‚úÖ Session mise √† jour")
            
        elif message_type == "conversation.item.input_text.delta":
            print(f"üìù Texte re√ßu: {data.get('delta', '')}", end="", flush=True)
            
        elif message_type == "conversation.item.input_text.done":
            print(f"\n‚úÖ Texte complet re√ßu: {data.get('text', '')}")
            
        elif message_type == "conversation.item.output_text.delta":
            print(f"üí¨ {data.get('delta', '')}", end="", flush=True)
            
        elif message_type == "conversation.item.output_text.done":
            print(f"\n‚úÖ R√©ponse compl√®te: {data.get('text', '')}")
            
        elif message_type == "conversation.item.tool_call":
            # Ex√©cute la fonction demand√©e
            await self.execute_tool_call(data.get("tool_call", {}))
            
        elif message_type == "error":
            print(f"‚ùå Erreur: {data.get('error', {})}")
            
        else:
            print(f"üì® Message: {message_type}")
    
    async def execute_tool_call(self, tool_call: Dict[str, Any]):
        """Ex√©cute un appel de fonction (simulation des outils MCP)"""
        function_name = tool_call.get("name")
        arguments = tool_call.get("arguments", {})
        
        print(f"üîß Ex√©cution de la fonction: {function_name}")
        
        try:
            if function_name == "create_folder":
                result = await self.create_folder(arguments.get("folder_path", ""))
            elif function_name == "create_file":
                result = await self.create_file(arguments.get("file_path", ""))
            elif function_name == "list_contents":
                result = await self.list_contents(arguments.get("folder_path", ""))
            else:
                result = f"Fonction {function_name} non reconnue"
            
            # Envoie le r√©sultat √† l'API
            tool_result = {
                "type": "conversation.item.tool_call.result",
                "tool_call_id": tool_call.get("id"),
                "result": result
            }
            
            await self.websocket.send(json.dumps(tool_result))
            print(f"üì§ R√©sultat envoy√©: {result}")
            
        except Exception as e:
            error_result = {
                "type": "conversation.item.tool_call.result",
                "tool_call_id": tool_call.get("id"),
                "result": f"Erreur: {str(e)}"
            }
            await self.websocket.send(json.dumps(error_result))
            print(f"‚ùå Erreur d'ex√©cution: {e}")
    
    async def create_folder(self, folder_path: str) -> str:
        """Cr√©e un dossier (simulation de l'outil MCP)"""
        if not folder_path:
            return "Erreur: chemin du dossier requis"
        
        try:
            desktop_path = os.path.expanduser("~/Desktop")
            full_path = os.path.join(desktop_path, folder_path)
            
            # S√©curise le chemin
            if not os.path.abspath(full_path).startswith(desktop_path):
                return "Erreur: chemin non autoris√©"
            
            os.makedirs(full_path, exist_ok=True)
            return f"Dossier '{folder_path}' cr√©√© avec succ√®s sur le Desktop"
            
        except Exception as e:
            return f"Erreur lors de la cr√©ation du dossier: {str(e)}"
    
    async def create_file(self, file_path: str) -> str:
        """Cr√©e un fichier (simulation de l'outil MCP)"""
        if not file_path:
            return "Erreur: chemin du fichier requis"
        
        try:
            desktop_path = os.path.expanduser("~/Desktop")
            full_path = os.path.join(desktop_path, file_path)
            
            # S√©curise le chemin
            if not os.path.abspath(full_path).startswith(desktop_path):
                return "Erreur: chemin non autoris√©"
            
            # Cr√©e le dossier parent si n√©cessaire
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            
            # Cr√©e le fichier vide
            with open(full_path, 'w') as f:
                pass
            
            return f"Fichier '{file_path}' cr√©√© avec succ√®s sur le Desktop"
            
        except Exception as e:
            return f"Erreur lors de la cr√©ation du fichier: {str(e)}"
    
    async def list_contents(self, folder_path: str) -> str:
        """Liste le contenu d'un dossier (simulation de l'outil MCP)"""
        try:
            desktop_path = os.path.expanduser("~/Desktop")
            if folder_path:
                full_path = os.path.join(desktop_path, folder_path)
            else:
                full_path = desktop_path
            
            # S√©curise le chemin
            if not os.path.abspath(full_path).startswith(desktop_path):
                return "Erreur: chemin non autoris√©"
            
            if not os.path.exists(full_path):
                return f"Le dossier '{folder_path or 'Desktop'}' n'existe pas"
            
            if not os.path.isdir(full_path):
                return f"Le chemin '{folder_path}' n'est pas un dossier"
            
            items = os.listdir(full_path)
            if not items:
                return f"Le dossier '{folder_path or 'Desktop'}' est vide"
            
            # Formate la liste
            result = f"Contenu du dossier '{folder_path or 'Desktop'}':\n"
            for item in sorted(items):
                item_path = os.path.join(full_path, item)
                if os.path.isdir(item_path):
                    result += f"üìÅ {item}/\n"
                else:
                    size = os.path.getsize(item_path)
                    size_str = f"{size} bytes" if size < 1024 else f"{size/1024:.1f} KB"
                    result += f"üìÑ {item} ({size_str})\n"
            
            return result
            
        except Exception as e:
            return f"Erreur lors de la lecture du dossier: {str(e)}"
    
    async def send_text_message(self, text: str):
        """Envoie un message texte √† l'API"""
        if not self.websocket or not self.is_connected:
            print("‚ùå Pas de connexion active")
            return
        
        message = {
            "type": "conversation.item.create",
            "item": {
                "type": "message",
                "role": "user",
                "content": [
                    {
                        "type": "input_text",
                        "text": text
                    }
                ]
            }
        }
        
        await self.websocket.send(json.dumps(message))
        print(f"üì§ Message envoy√©: {text}")
    
    async def run(self):
        """Lance le contr√¥leur simplifi√©"""
        try:
            # Connexion √† l'API
            await self.connect_to_api()
            
            print("\n" + "="*60)
            print("üé§ VOICE CONTROLLER SIMPLE (Mode Texte)")
            print("="*60)
            print("Commandes disponibles:")
            print("  - Tapez votre message et appuyez sur Entr√©e")
            print("  - Ctrl+C pour quitter")
            print("="*60)
            
            # Boucle principale
            while self.is_connected:
                try:
                    # Attend l'entr√©e utilisateur
                    user_input = await asyncio.get_event_loop().run_in_executor(
                        None, input, "\nüí¨ Votre message: "
                    )
                    
                    if user_input.strip():
                        await self.send_text_message(user_input.strip())
                    
                except KeyboardInterrupt:
                    break
                except EOFError:
                    break
            
        except Exception as e:
            print(f"‚ùå Erreur fatale: {e}")
        finally:
            await self.cleanup()
    
    async def cleanup(self):
        """Nettoie les ressources"""
        print("\nüßπ Nettoyage des ressources...")
        
        if self.websocket:
            await self.websocket.close()
        
        print("‚úÖ Nettoyage termin√©")


async def main():
    """Point d'entr√©e principal"""
    try:
        controller = VoiceControllerSimple()
        await controller.run()
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        print(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())




