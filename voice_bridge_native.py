#!/usr/bin/env python3
"""
Voice Bridge avec reconnaissance vocale native Mac
Solution sans OpenAI pour le hackathon - utilise Google Speech Recognition
"""
import speech_recognition as sr
import pyperclip
import sys
import time
from pathlib import Path

class VoiceBridgeNative:
    def __init__(self):
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        self.desktop_path = Path.home() / "Desktop"
        
        print("üé§ VOICE BRIDGE NATIF")
        print("="*40)
        print("‚úÖ Sans OpenAI - Reconnaissance vocale Google")
        print("üéØ Parfait pour le hackathon!")
        print("="*40)
        
        # Calibrer le microphone
        print("üîß Calibration du microphone...")
        with self.microphone as source:
            self.recognizer.adjust_for_ambient_noise(source, duration=1)
        print("‚úÖ Microphone calibr√©")
        
    def listen_and_transcribe(self, timeout=10):
        """√âcouter et transcrire avec la reconnaissance native"""
        print("\nüé§ üî¥ √âCOUTE EN COURS...")
        print("üí¨ Parlez maintenant (vous avez 10 secondes)...")
        
        try:
            with self.microphone as source:
                # √âcouter avec timeout
                audio = self.recognizer.listen(source, timeout=timeout, phrase_time_limit=8)
            
            print("üîÑ Transcription en cours...")
            
            # Essayer d'abord avec Google (gratuit)
            try:
                text = self.recognizer.recognize_google(audio, language='fr-FR')
                print(f"üìù ‚úÖ TRANSCRIPTION R√âUSSIE: '{text}'")
                return text
            except sr.UnknownValueError:
                print("‚ùå Parole non comprise")
                return None
            except sr.RequestError as e:
                print(f"‚ùå Erreur service Google: {e}")
                # Fallback vers reconnaissance offline si disponible
                try:
                    text = self.recognizer.recognize_sphinx(audio, language='fr-FR')
                    print(f"üìù ‚úÖ TRANSCRIPTION OFFLINE: '{text}'")
                    return text
                except:
                    print("‚ùå Reconnaissance offline non disponible")
                    return None
                    
        except sr.WaitTimeoutError:
            print("‚è∞ Timeout - Aucune parole d√©tect√©e")
            return None
        except Exception as e:
            print(f"‚ùå Erreur √©coute: {e}")
            return None
    
    def parse_voice_command(self, text):
        """Parser simple pour identifier les commandes"""
        text_lower = text.lower().strip()
        
        print(f"üîç Analyse de: '{text_lower}'")
        
        # Cr√©er dossier
        if "dossier" in text_lower and any(word in text_lower for word in ["cr√©e", "cr√©er", "fait", "faire"]):
            # Extraire le nom
            import re
            patterns = [
                r"dossier\s+([a-zA-Z0-9\s\-_]+)",
                r"cr[√©e]+[r]?\s+(?:un\s+)?dossier\s+([a-zA-Z0-9\s\-_]+)"
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    name = match.group(1).strip()
                    name = re.sub(r'\s+sur.*', '', name)
                    name = re.sub(r'\s+', '-', name)
                    name = re.sub(r'[^a-zA-Z0-9\-_]', '', name)
                    
                    if name:
                        print(f"‚úÖ Commande dossier: '{name}'")
                        return ("create_folder", name)
        
        # Cr√©er fichier
        if "fichier" in text_lower and any(word in text_lower for word in ["cr√©e", "cr√©er", "fait", "faire"]):
            import re
            patterns = [
                r"fichier\s+([a-zA-Z0-9\s\-_.]+)",
                r"cr[√©e]+[r]?\s+(?:un\s+)?fichier\s+([a-zA-Z0-9\s\-_.]+)"
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text_lower)
                if match:
                    name = match.group(1).strip()
                    name = re.sub(r'\s+sur.*', '', name)
                    name = re.sub(r'\s+', '_', name)
                    
                    if '.' not in name:
                        name += '.txt'
                    
                    if name:
                        print(f"‚úÖ Commande fichier: '{name}'")
                        return ("create_file", name)
        
        # Lister
        if any(word in text_lower for word in ["liste", "montre", "affiche", "contient"]) and "bureau" in text_lower:
            print(f"‚úÖ Commande liste")
            return ("list_contents", "")
        
        print(f"‚ùå Commande non reconnue")
        return None
    
    def execute_mcp_local(self, action, name):
        """Ex√©cuter l'action MCP localement"""
        print(f"\n‚öôÔ∏è EX√âCUTION MCP: {action}")
        
        if action == "create_folder":
            try:
                folder_path = self.desktop_path / name
                folder_path.mkdir(exist_ok=True)
                print(f"‚úÖ DOSSIER CR√â√â: {name}")
                return f"J'ai cr√©√© le dossier {name} sur votre bureau"
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
                return f"Erreur lors de la cr√©ation du dossier: {e}"
                
        elif action == "create_file":
            try:
                file_path = self.desktop_path / name
                file_path.touch()
                print(f"‚úÖ FICHIER CR√â√â: {name}")
                return f"J'ai cr√©√© le fichier {name} sur votre bureau"
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
                return f"Erreur lors de la cr√©ation du fichier: {e}"
                
        elif action == "list_contents":
            try:
                items = list(self.desktop_path.iterdir())
                folders = [item.name for item in items if item.is_dir()]
                files = [item.name for item in items if item.is_file() and not item.name.startswith('.')]
                
                print(f"‚úÖ CONTENU LIST√â: {len(folders)} dossiers, {len(files)} fichiers")
                
                result = f"Sur votre bureau, il y a {len(folders)} dossiers"
                if folders:
                    result += f": {', '.join(folders[:3])}"
                    if len(folders) > 3:
                        result += f" et {len(folders)-3} autres"
                
                result += f" et {len(files)} fichiers"
                if files:
                    result += f": {', '.join(files[:3])}"
                    if len(files) > 3:
                        result += f" et {len(files)-3} autres"
                
                return result
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
                return f"Erreur lors du listage: {e}"
        
        return "Action inconnue"
    
    def create_claude_prompt(self, voice_command, action_result):
        """Cr√©er un prompt pour Claude Desktop avec le r√©sultat"""
        prompt = f"""üé§ Commande vocale re√ßue: "{voice_command}"

‚úÖ Action ex√©cut√©e automatiquement: {action_result}

Utilise maintenant les outils MCP voice-file-controller pour confirmer ou compl√©ter cette action si n√©cessaire.

Commandes disponibles:
- create_folder: cr√©er des dossiers
- create_file: cr√©er des fichiers
- list_contents: lister le contenu

La commande a d√©j√† √©t√© ex√©cut√©e localement, mais tu peux utiliser les outils MCP pour v√©rifier ou faire des actions compl√©mentaires."""

        return prompt
    
    def copy_to_clipboard(self, text):
        """Copier dans le presse-papier"""
        try:
            pyperclip.copy(text)
            print("‚úÖ Prompt copi√© dans le presse-papier!")
            print("üëâ Collez dans Claude Desktop (Cmd+V)")
            return True
        except Exception as e:
            print(f"‚ùå Erreur copie: {e}")
            return False
    
    def run_voice_session(self):
        """Session vocale compl√®te"""
        print("\n" + "="*60)
        print("üé§ SESSION VOCALE NATIVE")
        print("="*60)
        print("üí¨ Exemples de commandes:")
        print("   ‚Ä¢ 'Cr√©e un dossier projet-hackathon'")
        print("   ‚Ä¢ 'Cr√©e un fichier readme'")
        print("   ‚Ä¢ 'Montre-moi le bureau'")
        print("="*60)
        
        try:
            # 1. √âcouter et transcrire
            text = self.listen_and_transcribe()
            
            if not text:
                print("‚ùå Aucune transcription obtenue")
                return
            
            # 2. Parser la commande
            command = self.parse_voice_command(text)
            
            if not command:
                print("‚ùå Commande non reconnue")
                # Cr√©er quand m√™me un prompt pour Claude
                prompt = f"""Commande vocale non reconnue: "{text}"

Peux-tu analyser cette commande et utiliser les outils MCP appropri√©s:
- create_folder: cr√©er des dossiers
- create_file: cr√©er des fichiers
- list_contents: lister le contenu"""
                
                if self.copy_to_clipboard(prompt):
                    print("üìã Prompt envoy√© √† Claude pour analyse")
                return
            
            # 3. Ex√©cuter l'action MCP localement
            action, name = command
            result = self.execute_mcp_local(action, name)
            
            # 4. Cr√©er le prompt pour Claude
            prompt = self.create_claude_prompt(text, result)
            
            # 5. Copier dans le presse-papier
            if self.copy_to_clipboard(prompt):
                print("\n" + "="*60)
                print("PROMPT G√âN√âR√â POUR CLAUDE:")
                print("="*60)
                print(prompt)
                print("="*60)
                print("\nüéØ Dans Claude Desktop:")
                print("1. Ouvrez une conversation")
                print("2. Collez avec Cmd+V")
                print("3. Appuyez sur Entr√©e")
                print("4. Claude utilisera les outils MCP!")
            
        except Exception as e:
            print(f"‚ùå Erreur session: {e}")
    
    def run_continuous_demo(self):
        """Mode d√©mo continu pour le hackathon"""
        print("\nüîÑ MODE D√âMO HACKATHON")
        print("="*40)
        print("Commandes vocales en boucle")
        print("Entr√©e = nouvelle commande, 'q' = quitter")
        
        session_count = 0
        
        while True:
            try:
                session_count += 1
                print(f"\nüéØ SESSION #{session_count}")
                
                choice = input("üëâ Appuyez sur Entr√©e pour parler (q pour quitter): ").strip()
                if choice.lower() == 'q':
                    break
                
                self.run_voice_session()
                
                print("\n‚è≥ Pr√™t pour la prochaine commande...")
                
            except KeyboardInterrupt:
                print("\nüëã D√©mo termin√©e!")
                break
    
    def test_microphone_simple(self):
        """Test simple du microphone"""
        print("\nüé§ Test microphone (parlez pendant 3 secondes)...")
        
        try:
            with self.microphone as source:
                self.recognizer.adjust_for_ambient_noise(source, duration=0.5)
                print("üî¥ Parlez maintenant...")
                audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=3)
            
            print("‚úÖ Audio captur√©!")
            
            # Test transcription
            try:
                text = self.recognizer.recognize_google(audio, language='fr-FR')
                print(f"üìù Transcription: '{text}'")
                return True
            except Exception as e:
                print(f"‚ùå Transcription √©chou√©e: {e}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur microphone: {e}")
            return False
    
    def show_menu(self):
        """Menu principal"""
        print("\n" + "="*50)
        print("üé§ VOICE BRIDGE NATIF - HACKATHON")
        print("="*50)
        print("üß™ TESTS:")
        print("  1 - Test microphone simple")
        print("  2 - Session vocale unique")
        print("  3 - Mode d√©mo continu (hackathon)")
        print()
        print("üìã COMMANDES SUPPORT√âES:")
        print("  ‚Ä¢ 'Cr√©e un dossier [nom]'")
        print("  ‚Ä¢ 'Cr√©e un fichier [nom]'")
        print("  ‚Ä¢ 'Montre-moi le bureau'")
        print("  ‚Ä¢ 'Liste le bureau'")
        print()
        print("‚ùå q - Quitter")
        print("="*50)
    
    def run(self):
        """Fonction principale"""
        print("üé§ VOICE BRIDGE NATIF")
        print("üéØ Reconnaissance vocale sans OpenAI")
        
        try:
            while True:
                try:
                    self.show_menu()
                    choice = input("\nüëâ Votre choix: ").strip()
                    
                    if choice.lower() == 'q':
                        break
                        
                    elif choice == '1':
                        self.test_microphone_simple()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '2':
                        self.run_voice_session()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '3':
                        self.run_continuous_demo()
                        
                    else:
                        print("‚ùå Choix invalide. Utilisez 1-3 ou 'q'")
                        
                except EOFError:
                    print("\nüëã Au revoir!")
                    break
                    
        except KeyboardInterrupt:
            print("\nüëã Au revoir!")

if __name__ == "__main__":
    # V√©rifier les d√©pendances
    try:
        import speech_recognition as sr
        import pyperclip
    except ImportError as e:
        print(f"‚ùå D√©pendance manquante: {e}")
        print("üí° Installez avec: pip install SpeechRecognition pyperclip")
        sys.exit(1)
    
    try:
        bridge = VoiceBridgeNative()
        bridge.run()
    except KeyboardInterrupt:
        print("\nüëã Programme arr√™t√©")
