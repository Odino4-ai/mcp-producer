#!/usr/bin/env python3
"""
D√©mo Simple Voice ‚Üí MCP
Version ultra-simplifi√©e qui fonctionne √©tape par √©tape
"""
import asyncio
import json
import os
import sys
import sounddevice as sd
import numpy as np
import websockets
from dotenv import load_dotenv
from pathlib import Path
import threading
import base64
import re

load_dotenv()

class SimpleVoiceDemo:
    def __init__(self):
        self.api_key = os.getenv('OPENAI_API_KEY')
        self.desktop_path = Path.home() / "Desktop"
        self.ws = None
        
    # ========== FONCTIONS MCP LOCALES ==========
    def mcp_create_folder(self, name):
        """Cr√©er un dossier - version locale simple"""
        try:
            folder_path = self.desktop_path / name
            folder_path.mkdir(exist_ok=True)
            print(f"‚úÖ DOSSIER CR√â√â: {folder_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erreur: {e}")
            return False
    
    def mcp_create_file(self, name):
        """Cr√©er un fichier - version locale simple"""
        try:
            if '.' not in name:
                name += '.txt'
            file_path = self.desktop_path / name
            file_path.touch()
            print(f"‚úÖ FICHIER CR√â√â: {file_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erreur: {e}")
            return False
    
    def mcp_list_desktop(self):
        """Lister le bureau - version locale simple"""
        try:
            items = list(self.desktop_path.iterdir())
            folders = [item.name for item in items if item.is_dir()]
            files = [item.name for item in items if item.is_file() and not item.name.startswith('.')]
            
            print(f"‚úÖ CONTENU DU BUREAU:")
            print(f"   üìÅ {len(folders)} dossiers: {folders[:3]}")
            print(f"   üìÑ {len(files)} fichiers: {files[:3]}")
            return True
        except Exception as e:
            print(f"‚ùå Erreur: {e}")
            return False
    
    # ========== PARSING SIMPLE ==========
    def parse_simple_command(self, text):
        """Parser ultra-simple"""
        text_lower = text.lower()
        
        print(f"\nüîç PARSING: '{text}'")
        
        # Dossier
        if "dossier" in text_lower and ("cr√©e" in text_lower or "cr√©er" in text_lower):
            # Extraire le nom apr√®s "dossier"
            match = re.search(r'dossier\s+([a-zA-Z0-9\s\-_]+)', text_lower)
            if match:
                name = match.group(1).strip()
                name = re.sub(r'\s+', '-', name)
                name = re.sub(r'[^a-zA-Z0-9\-_]', '', name)
                if name:
                    print(f"‚úÖ Commande dossier: '{name}'")
                    return ("folder", name)
        
        # Fichier
        if "fichier" in text_lower and ("cr√©e" in text_lower or "cr√©er" in text_lower):
            match = re.search(r'fichier\s+([a-zA-Z0-9\s\-_.]+)', text_lower)
            if match:
                name = match.group(1).strip()
                name = re.sub(r'\s+', '_', name)
                if name:
                    print(f"‚úÖ Commande fichier: '{name}'")
                    return ("file", name)
        
        # Liste
        if any(word in text_lower for word in ["liste", "montre", "affiche", "contient"]) and "bureau" in text_lower:
            print(f"‚úÖ Commande liste")
            return ("list", "")
        
        print(f"‚ùå Commande non reconnue")
        return None
    
    # ========== TEST AUDIO SIMPLE ==========
    async def test_microphone(self):
        """Test simple du microphone"""
        print("\nüé§ TEST MICROPHONE (3 secondes)")
        print("Parlez maintenant...")
        
        # Enregistrer
        duration = 3
        sample_rate = 44100
        
        try:
            recording = sd.rec(int(duration * sample_rate), 
                              samplerate=sample_rate, 
                              channels=1, 
                              dtype=np.float32)
            sd.wait()
            
            # Analyser
            max_vol = np.max(np.abs(recording))
            rms = np.sqrt(np.mean(recording**2))
            
            print(f"üìä Volume max: {max_vol:.4f}")
            print(f"üìä RMS: {rms:.4f}")
            
            if max_vol > 0.01:
                print("‚úÖ Microphone fonctionne!")
                
                # Sauvegarder pour test
                import wave
                test_file = "test_audio.wav"
                
                # Convertir en int16
                audio_int = (recording * 32767).astype(np.int16)
                
                with wave.open(test_file, 'w') as wf:
                    wf.setnchannels(1)
                    wf.setsampwidth(2)
                    wf.setframerate(sample_rate)
                    wf.writeframes(audio_int.tobytes())
                
                print(f"üíæ Audio sauv√© dans {test_file}")
                return True
            else:
                print("‚ùå Pas d'audio d√©tect√©")
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur test micro: {e}")
            return False
    
    # ========== TRANSCRIPTION OPENAI SIMPLE ==========
    async def test_transcription_simple(self):
        """Test de transcription avec OpenAI simple"""
        if not await self.test_microphone():
            print("‚ùå Test microphone √©chou√©")
            return
        
        print("\nüîó Test transcription OpenAI...")
        
        # Lire le fichier audio de test
        try:
            import wave
            with wave.open("test_audio.wav", 'rb') as wf:
                audio_data = wf.readframes(wf.getnframes())
            
            # Connecter √† OpenAI
            headers = {
                'Authorization': f'Bearer {self.api_key}',
                'OpenAI-Beta': 'realtime=v1'
            }
            
            uri = f"wss://api.openai.com/v1/realtime?model={self.model}"
            
            try:
                self.ws = await websockets.connect(uri, additional_headers=headers)
                print("‚úÖ Connexion OpenAI OK")
                
                # Configuration simple
                config = {
                    "type": "session.update",
                    "session": {
                        "modalities": ["audio"],
                        "input_audio_transcription": {"model": "whisper-1"}
                    }
                }
                
                await self.ws.send(json.dumps(config))
                
                # Envoyer l'audio
                audio_b64 = base64.b64encode(audio_data).decode('utf-8')
                
                # Cr√©er item audio
                audio_item = {
                    "type": "conversation.item.create",
                    "item": {
                        "type": "message",
                        "role": "user",
                        "content": [
                            {
                                "type": "input_audio",
                                "audio": audio_b64
                            }
                        ]
                    }
                }
                
                await self.ws.send(json.dumps(audio_item))
                print("üì§ Audio envoy√© pour transcription")
                
                # √âcouter la r√©ponse
                timeout = 10
                start_time = asyncio.get_event_loop().time()
                
                async for message in self.ws:
                    if asyncio.get_event_loop().time() - start_time > timeout:
                        print("‚è∞ Timeout")
                        break
                    
                    try:
                        event = json.loads(message)
                        event_type = event.get("type")
                        
                        if event_type == "conversation.item.input_audio_transcription.completed":
                            transcript = event.get("transcript", "")
                            print(f"üìù ‚úÖ TRANSCRIPTION: '{transcript}'")
                            
                            # TEST DU PARSING
                            command = self.parse_simple_command(transcript)
                            if command:
                                action, name = command
                                print(f"üéØ COMMANDE IDENTIFI√âE: {action} -> {name}")
                                
                                # EX√âCUTION MCP
                                if action == "folder":
                                    success = self.mcp_create_folder(name)
                                elif action == "file":
                                    success = self.mcp_create_file(name)
                                elif action == "list":
                                    success = self.mcp_list_desktop()
                                
                                if success:
                                    print("üéâ SUCC√àS COMPLET! Voix ‚Üí Transcription ‚Üí Parsing ‚Üí MCP ‚úÖ")
                                else:
                                    print("‚ùå √âchec MCP")
                            else:
                                print("‚ùå Commande non reconnue")
                            
                            break
                            
                        elif event_type == "conversation.item.input_audio_transcription.failed":
                            error = event.get("error", {})
                            print(f"‚ùå TRANSCRIPTION √âCHOU√âE: {error}")
                            break
                            
                    except Exception as e:
                        print(f"‚ùå Erreur √©v√©nement: {e}")
                
                await self.ws.close()
                
            except Exception as e:
                print(f"‚ùå Erreur WebSocket: {e}")
                
        except Exception as e:
            print(f"‚ùå Erreur lecture audio: {e}")
    
    # ========== TEST COMPLET √âTAPE PAR √âTAPE ==========
    async def demo_step_by_step(self):
        """D√©mo compl√®te √©tape par √©tape"""
        print("\n" + "="*60)
        print("üéØ D√âMO √âTAPE PAR √âTAPE: VOIX ‚Üí MCP")
        print("="*60)
        
        # √âtape 1: Test microphone
        print("\nüìç √âTAPE 1: Test du microphone")
        print("-" * 30)
        input("Appuyez sur Entr√©e pour tester votre microphone...")
        
        if not await self.test_microphone():
            print("‚ùå Microphone ne fonctionne pas - Arr√™t")
            return
        
        print("‚úÖ Microphone OK!")
        
        # √âtape 2: Test transcription
        print("\nüìç √âTAPE 2: Test transcription + parsing + MCP")
        print("-" * 30)
        print("üé§ Dites: 'Cr√©e un dossier test-demo'")
        input("Appuyez sur Entr√©e quand vous √™tes pr√™t...")
        
        await self.test_transcription_simple()
        
        # √âtape 3: V√©rification
        print("\nüìç √âTAPE 3: V√©rification")
        print("-" * 30)
        
        test_folder = self.desktop_path / "test-demo"
        if test_folder.exists():
            print("üéâ SUCC√àS TOTAL! Le dossier a √©t√© cr√©√©!")
            print(f"üìÅ V√©rifiez votre bureau: {test_folder}")
        else:
            print("‚ùå Le dossier n'a pas √©t√© cr√©√©")
        
        print("\n‚úÖ D√©mo termin√©e")
    
    # ========== INTERFACE ==========
    def show_menu(self):
        print("\n" + "="*50)
        print("üéØ D√âMO SIMPLE VOICE ‚Üí MCP")
        print("="*50)
        print("1Ô∏è‚É£  - Test microphone seulement")
        print("2Ô∏è‚É£  - Test transcription + MCP")
        print("3Ô∏è‚É£  - D√©mo compl√®te √©tape par √©tape")
        print("4Ô∏è‚É£  - Test parsing manuel")
        print("‚ùå q - Quitter")
        print("="*50)
    
    async def test_parsing_manual(self):
        """Test du parsing manuellement"""
        print("\nüß™ Test parsing manuel")
        
        examples = [
            "Cr√©e un dossier projet",
            "Cr√©e un dossier test-demo", 
            "Cr√©e un fichier readme.txt",
            "Liste le bureau",
            "Montre-moi le bureau"
        ]
        
        print("Exemples:")
        for i, ex in enumerate(examples, 1):
            print(f"  {i}. {ex}")
        
        text = input("\nTapez une commande ou choisissez (1-5): ").strip()
        
        if text.isdigit() and 1 <= int(text) <= 5:
            text = examples[int(text) - 1]
        
        if text:
            command = self.parse_simple_command(text)
            if command:
                action, name = command
                print(f"‚úÖ Parsing r√©ussi: {action} -> {name}")
                
                # Ex√©cuter directement
                if action == "folder":
                    self.mcp_create_folder(name)
                elif action == "file":
                    self.mcp_create_file(name)
                elif action == "list":
                    self.mcp_list_desktop()
            else:
                print("‚ùå Parsing √©chou√©")
    
    async def run(self):
        """Fonction principale"""
        print("üéØ D√âMO SIMPLE VOICE ‚Üí MCP")
        print("="*30)
        print("üéØ Test chaque √©tape individuellement")
        
        try:
            while True:
                try:
                    self.show_menu()
                    choice = input("\nüëâ Votre choix: ").strip()
                    
                    if choice.lower() == 'q':
                        break
                        
                    elif choice == '1':
                        await self.test_microphone()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '2':
                        await self.test_transcription_simple()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '3':
                        await self.demo_step_by_step()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '4':
                        await self.test_parsing_manual()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    else:
                        print("‚ùå Choix invalide")
                        
                except EOFError:
                    break
                    
        except KeyboardInterrupt:
            print("\nüëã Au revoir!")

if __name__ == "__main__":
    try:
        demo = SimpleVoiceDemo()
        asyncio.run(demo.run())
    except KeyboardInterrupt:
        print("\nüëã Programme arr√™t√©")
