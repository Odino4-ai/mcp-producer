#!/usr/bin/env python3
"""
Debugger de Transcription OpenAI
Outil sp√©cialis√© pour diagnostiquer les probl√®mes de transcription audio
"""
import asyncio
import json
import os
import sys
import sounddevice as sd
import numpy as np
import websockets
from dotenv import load_dotenv
import threading
import signal
import queue
import base64
import time

load_dotenv()

class TranscriptionDebugger:
    def __init__(self):
        self.api_key = os.getenv('OPENAI_API_KEY')
        self.model = os.getenv('OPENAI_REALTIME_MODEL', 'gpt-4o-realtime-preview-2024-10-01')
        self.ws = None
        self.is_recording = False
        self.recording_stopped = threading.Event()
        
        # Statistiques de debug
        self.audio_stats = {
            "chunks_sent": 0,
            "chunks_filtered": 0,
            "total_bytes": 0,
            "recording_duration": 0,
            "transcription_attempts": 0,
            "transcription_successes": 0,
            "transcription_failures": 0
        }
        
        self.audio_queue = queue.Queue(maxsize=200)
        self.connection_active = True
        self.session_created = False
        
    async def connect_to_realtime(self):
        """Connexion optimis√©e pour la transcription"""
        headers = {
            'Authorization': f'Bearer {self.api_key}',
            'OpenAI-Beta': 'realtime=v1'
        }
        
        uri = f"wss://api.openai.com/v1/realtime?model={self.model}"
        
        try:
            print("üîó Connexion √† OpenAI pour debug transcription...")
            self.ws = await websockets.connect(
                uri, 
                additional_headers=headers,
                ping_interval=30,
                ping_timeout=15,
                close_timeout=10
            )
            print("‚úÖ Connexion √©tablie")
            return True
        except Exception as e:
            print(f"‚ùå Erreur connexion: {e}")
            return False
    
    async def send_optimized_session_config(self):
        """Configuration optimis√©e pour la transcription"""
        config = {
            "type": "session.update",
            "session": {
                "modalities": ["audio", "text"],
                "instructions": "Tu es un assistant de test. R√©p√®te simplement ce que tu entends pour confirmer la transcription.",
                "voice": "alloy",
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {
                    "model": "whisper-1"
                },
                "turn_detection": {
                    "type": "server_vad",
                    "threshold": 0.2,  # Seuil tr√®s bas
                    "prefix_padding_ms": 800,  # Beaucoup de padding
                    "silence_duration_ms": 800  # Attendre longtemps
                }
            }
        }
        
        try:
            await self.ws.send(json.dumps(config))
            print("üì§ Configuration optimis√©e envoy√©e")
        except Exception as e:
            print(f"‚ùå Erreur config: {e}")
    
    async def listen_to_events(self):
        """√âcouter et analyser tous les √©v√©nements"""
        try:
            async for message in self.ws:
                try:
                    event = json.loads(message)
                    await self.analyze_event(event)
                except json.JSONDecodeError:
                    print(f"‚ùå JSON invalide: {message}")
                except Exception as e:
                    print(f"‚ùå Erreur √©v√©nement: {e}")
                    
        except websockets.exceptions.ConnectionClosed:
            print("üîå Connexion ferm√©e")
            self.connection_active = False
        except Exception as e:
            print(f"‚ùå Erreur √©coute: {e}")
            self.connection_active = False
    
    async def analyze_event(self, event):
        """Analyser les √©v√©nements pour le debug"""
        event_type = event.get("type")
        timestamp = time.strftime("%H:%M:%S")
        
        if event_type == "session.created":
            print(f"[{timestamp}] ‚úÖ Session cr√©√©e")
            self.session_created = True
            
        elif event_type == "session.updated":
            print(f"[{timestamp}] ‚úÖ Session mise √† jour")
            
        elif event_type == "input_audio_buffer.speech_started":
            print(f"[{timestamp}] üé§ üü¢ VAD: D√©but de parole")
            
        elif event_type == "input_audio_buffer.speech_stopped":
            print(f"[{timestamp}] üîá üî¥ VAD: Fin de parole")
            
        elif event_type == "input_audio_buffer.committed":
            print(f"[{timestamp}] üì¶ Buffer audio committ√©")
            self.audio_stats["transcription_attempts"] += 1
            
        elif event_type == "conversation.item.created":
            print(f"[{timestamp}] üìù Item de conversation cr√©√©")
            
        elif event_type == "conversation.item.input_audio_transcription.completed":
            transcript = event.get("transcript", "")
            print(f"[{timestamp}] ‚úÖ TRANSCRIPTION R√âUSSIE: '{transcript}'")
            self.audio_stats["transcription_successes"] += 1
            
        elif event_type == "conversation.item.input_audio_transcription.failed":
            error = event.get("error", {})
            print(f"[{timestamp}] ‚ùå TRANSCRIPTION √âCHOU√âE: {error}")
            self.audio_stats["transcription_failures"] += 1
            
            # Analyser la cause
            if "too short" in str(error).lower():
                print("   üí° Cause: Audio trop court")
            elif "quality" in str(error).lower():
                print("   üí° Cause: Qualit√© audio insuffisante")
            elif "format" in str(error).lower():
                print("   üí° Cause: Probl√®me de format")
            else:
                print("   üí° Cause: Inconnue")
            
        elif event_type == "response.created":
            print(f"[{timestamp}] ü§ñ R√©ponse en cours de g√©n√©ration")
            
        elif event_type == "response.done":
            print(f"[{timestamp}] ‚úÖ R√©ponse termin√©e")
            
        elif event_type == "error":
            error_details = event.get("error", {})
            print(f"[{timestamp}] ‚ùå ERREUR SERVEUR: {error_details}")
    
    def audio_callback_debug(self, indata, frames, time, status):
        """Callback audio avec debug d√©taill√©"""
        if status:
            print(f"‚ö†Ô∏è Status: {status}")
        
        if self.is_recording and self.ws and self.session_created:
            try:
                # Analyser la qualit√© audio
                audio_float = indata[:, 0]
                volume_norm = np.linalg.norm(audio_float) * 10
                
                # Convertir en PCM16
                audio_data = (audio_float * 32767).astype(np.int16)
                max_amplitude = np.max(np.abs(audio_data))
                rms = np.sqrt(np.mean(audio_data.astype(np.float32)**2))
                
                # Statistiques
                chunk_size = len(audio_data.tobytes())
                self.audio_stats["total_bytes"] += chunk_size
                
                # Crit√®res de qualit√© am√©lior√©s
                quality_ok = (
                    max_amplitude > 100 and  # Amplitude minimum
                    rms > 50 and           # RMS minimum
                    volume_norm > 5        # Volume visuel minimum
                )
                
                if quality_ok:
                    # Encoder et envoyer
                    audio_b64 = base64.b64encode(audio_data.tobytes()).decode('utf-8')
                    
                    audio_event = {
                        "type": "input_audio_buffer.append",
                        "audio": audio_b64
                    }
                    
                    try:
                        self.audio_queue.put_nowait(json.dumps(audio_event))
                        self.audio_stats["chunks_sent"] += 1
                        
                        # Debug visuel
                        if max_amplitude > 1000:
                            print(f" [‚úÖ ENVOY√â: {max_amplitude:.0f}]", end="")
                    except queue.Full:
                        pass
                else:
                    self.audio_stats["chunks_filtered"] += 1
                    # Debug: pourquoi filtr√©
                    if volume_norm > 10:  # Volume visuel fort mais qualit√© faible
                        print(f" [‚ùå FILTR√â: amp={max_amplitude:.0f}, rms={rms:.0f}]", end="")
                    
            except Exception as e:
                print(f"‚ùå Erreur callback: {e}")
    
    async def process_audio_queue(self):
        """Traiter la queue avec statistiques"""
        while self.connection_active:
            try:
                message = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.audio_queue.get(timeout=0.1)
                )
                await self.safe_send(message)
            except queue.Empty:
                await asyncio.sleep(0.01)
            except Exception as e:
                print(f"‚ùå Erreur queue: {e}")
    
    async def safe_send(self, message):
        """Envoi s√©curis√©"""
        try:
            if self.ws and self.connection_active:
                await self.ws.send(message)
                return True
        except Exception as e:
            if "1000" not in str(e):
                print(f"‚ùå Envoi: {e}")
            return False
        return False
    
    def wait_for_enter(self):
        """Attendre entr√©e utilisateur"""
        try:
            input("Appuyez sur Entr√©e pour arr√™ter...")
            self.recording_stopped.set()
        except:
            self.recording_stopped.set()
    
    async def debug_recording_session(self):
        """Session d'enregistrement avec debug complet"""
        print("\n" + "="*60)
        print("üîç SESSION DE DEBUG TRANSCRIPTION")
        print("="*60)
        print("üí¨ Parlez CLAIREMENT et DISTINCTEMENT")
        print("‚è∞ Parlez pendant au moins 3-4 secondes")
        print("üîä √âvitez les bruits de fond")
        print("‚èπÔ∏è  Appuyez sur Entr√©e pour arr√™ter")
        print("="*60)
        
        # Reset des stats
        self.audio_stats = {
            "chunks_sent": 0,
            "chunks_filtered": 0,
            "total_bytes": 0,
            "recording_duration": 0,
            "transcription_attempts": 0,
            "transcription_successes": 0,
            "transcription_failures": 0
        }
        
        self.is_recording = True
        self.recording_stopped.clear()
        
        # Thread pour attendre l'entr√©e
        input_thread = threading.Thread(target=self.wait_for_enter)
        input_thread.daemon = True
        input_thread.start()
        
        start_time = time.time()
        
        try:
            # Configuration audio optimis√©e pour la transcription
            with sd.InputStream(
                callback=self.audio_callback_debug,
                channels=1,
                samplerate=24000,  # Fr√©quence recommand√©e par OpenAI
                dtype=np.float32,
                blocksize=2048,   # Blocs plus grands pour meilleure qualit√©
                latency='high'    # Latence plus √©lev√©e pour meilleure qualit√©
            ):
                while not self.recording_stopped.is_set():
                    await asyncio.sleep(0.1)
                    
        except Exception as e:
            print(f"‚ùå Erreur enregistrement: {e}")
        
        self.is_recording = False
        end_time = time.time()
        self.audio_stats["recording_duration"] = end_time - start_time
        
        print(f"\nüîá Enregistrement termin√©")
        
        # Attendre un peu pour les √©v√©nements de transcription
        print("‚è≥ Attente des r√©sultats de transcription...")
        await asyncio.sleep(3)
        
        # Afficher les statistiques
        self.show_debug_stats()
    
    def show_debug_stats(self):
        """Afficher les statistiques de debug"""
        stats = self.audio_stats
        
        print("\n" + "="*50)
        print("üìä STATISTIQUES DE DEBUG")
        print("="*50)
        print(f"‚è±Ô∏è  Dur√©e d'enregistrement: {stats['recording_duration']:.2f}s")
        print(f"üì¶ Chunks audio envoy√©s: {stats['chunks_sent']}")
        print(f"üö´ Chunks filtr√©s: {stats['chunks_filtered']}")
        print(f"üíæ Total bytes audio: {stats['total_bytes']}")
        
        if stats['recording_duration'] > 0:
            bytes_per_sec = stats['total_bytes'] / stats['recording_duration']
            print(f"üìà D√©bit audio: {bytes_per_sec:.0f} bytes/sec")
        
        print(f"\nüìù Tentatives de transcription: {stats['transcription_attempts']}")
        print(f"‚úÖ Transcriptions r√©ussies: {stats['transcription_successes']}")
        print(f"‚ùå Transcriptions √©chou√©es: {stats['transcription_failures']}")
        
        if stats['transcription_attempts'] > 0:
            success_rate = (stats['transcription_successes'] / stats['transcription_attempts']) * 100
            print(f"üìä Taux de r√©ussite: {success_rate:.1f}%")
        
        # Diagnostic
        print(f"\nüîç DIAGNOSTIC:")
        if stats['chunks_sent'] == 0:
            print("‚ùå Aucun audio envoy√© - Probl√®me de capture ou qualit√©")
        elif stats['chunks_sent'] < 10:
            print("‚ö†Ô∏è Peu d'audio envoy√© - Parlez plus fort ou plus longtemps")
        elif stats['transcription_failures'] > stats['transcription_successes']:
            print("‚ö†Ô∏è Beaucoup d'√©checs - Probl√®me de qualit√© audio")
        elif stats['transcription_successes'] > 0:
            print("‚úÖ Transcription fonctionne - Audio de bonne qualit√©")
        else:
            print("ü§î Audio envoy√© mais pas de tentative de transcription")
        
        print("="*50)
    
    def show_menu(self):
        """Menu du debugger"""
        print("\n" + "="*60)
        print("üîç DEBUGGER DE TRANSCRIPTION OPENAI")
        print("="*60)
        print("1Ô∏è‚É£  - Test de transcription avec debug complet")
        print("2Ô∏è‚É£  - Test qualit√© audio (sans OpenAI)")
        print("3Ô∏è‚É£  - Afficher les derni√®res statistiques")
        print("4Ô∏è‚É£  - Reset des statistiques")
        print("‚ùå q - Quitter")
        print("="*60)
    
    def test_audio_quality(self):
        """Test de qualit√© audio local"""
        print("\nüé§ Test de qualit√© audio (5 secondes)")
        print("Parlez maintenant...")
        
        # Enregistrer 5 secondes
        duration = 5
        sample_rate = 24000
        
        recording = sd.rec(int(duration * sample_rate), 
                          samplerate=sample_rate, 
                          channels=1, 
                          dtype=np.float32)
        sd.wait()
        
        # Analyser la qualit√©
        audio_data = (recording[:, 0] * 32767).astype(np.int16)
        max_amplitude = np.max(np.abs(audio_data))
        rms = np.sqrt(np.mean(audio_data.astype(np.float32)**2))
        volume_norm = np.linalg.norm(recording[:, 0]) * 10
        
        print(f"\nüìä Analyse de qualit√©:")
        print(f"   Amplitude max: {max_amplitude:.0f}")
        print(f"   RMS: {rms:.0f}")
        print(f"   Volume visuel moyen: {volume_norm:.1f}")
        
        # Crit√®res de qualit√©
        print(f"\nüéØ Crit√®res de qualit√©:")
        print(f"   Amplitude > 100: {'‚úÖ' if max_amplitude > 100 else '‚ùå'} ({max_amplitude:.0f})")
        print(f"   RMS > 50: {'‚úÖ' if rms > 50 else '‚ùå'} ({rms:.0f})")
        print(f"   Volume > 5: {'‚úÖ' if volume_norm > 5 else '‚ùå'} ({volume_norm:.1f})")
        
        if max_amplitude > 100 and rms > 50:
            print("‚úÖ Qualit√© suffisante pour la transcription")
        else:
            print("‚ùå Qualit√© insuffisante - parlez plus fort")
    
    async def run(self):
        """Fonction principale"""
        print("üîç DEBUGGER DE TRANSCRIPTION")
        print("="*40)
        print("üéØ Diagnostiquer les probl√®mes de transcription OpenAI")
        
        try:
            while True:
                try:
                    self.show_menu()
                    choice = input("\nüëâ Votre choix: ").strip()
                    
                    if choice.lower() == 'q':
                        break
                        
                    elif choice == '1':
                        if await self.connect_to_realtime():
                            await self.send_optimized_session_config()
                            
                            # D√©marrer les t√¢ches
                            event_task = asyncio.create_task(self.listen_to_events())
                            audio_task = asyncio.create_task(self.process_audio_queue())
                            
                            await self.debug_recording_session()
                            
                            event_task.cancel()
                            audio_task.cancel()
                            
                            try:
                                await self.ws.close()
                            except:
                                pass
                        else:
                            print("‚ùå Impossible de se connecter")
                            
                    elif choice == '2':
                        self.test_audio_quality()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '3':
                        self.show_debug_stats()
                        input("\nAppuyez sur Entr√©e pour continuer...")
                        
                    elif choice == '4':
                        self.audio_stats = {
                            "chunks_sent": 0,
                            "chunks_filtered": 0,
                            "total_bytes": 0,
                            "recording_duration": 0,
                            "transcription_attempts": 0,
                            "transcription_successes": 0,
                            "transcription_failures": 0
                        }
                        print("‚úÖ Statistiques r√©initialis√©es")
                        
                    else:
                        print("‚ùå Choix invalide")
                        
                except EOFError:
                    print("\nüëã Au revoir!")
                    break
                    
        except KeyboardInterrupt:
            print("\nüëã Au revoir!")
        finally:
            self.connection_active = False

if __name__ == "__main__":
    def signal_handler(sig, frame):
        print('\nüëã Arr√™t...')
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    try:
        debugger = TranscriptionDebugger()
        asyncio.run(debugger.run())
    except KeyboardInterrupt:
        print("\nüëã Programme arr√™t√©")
